// Logic
// 1. 배열 순서대로 티켓을 구매할 수 있기에 k 이전, 이후로 나뉨
// 2. 우선 기본적으로 해당 사람이 구매해야할 티켓, k번째 사람이 구매해야 할 티켓 중 최솟값의 시간을 누적해야한다. 
// 3. 만약 k번째 이전의 사람이었다면 무조건 구매를 보장받는다. (k보다 앞서있기에) 그래서 자기자신과 k의 개수사이에서 최소값을 구해 시간을 더한다
// 4. 만약 k번째 이후의 사람이었다면, k가 먼저 충족해버리면 구매를 하지 못하게 된다. 즉 이에 k번째 사람이 요구하는 티켓 - 1과 본인 중 최솟값을 구해 시간에 더한다.

// 1 1 5 4인 경우에서 k = 2가 모든 티켓을 구매할 수 있는 시간을 구하라고 가정해보자. 
// 앞의 1 1은 무조건 구매를 보장받기 때문에 1과 5를 비교하여 최솟값인 1을 더해준다. 
// 하지만 k의 뒤인 4의 경우 구매를 보장받을 수도 없을 수도 있다. 
// 만약 k의 값보다 컸다면 k의 수 - 1 만큼 보장받았을 것이고, k보다 작았더라면 본인의 티켓을 모두 구매가능했을 것이다. 
// 이에 k이후의 값들은 arr[k] - 1와 최솟값을 비교하게 되는 것이다. 

// Solution 
class Solution {
    func timeRequiredToBuy(_ tickets: [Int], _ k: Int) -> Int {        
        var totalTime = 0
       
        for (i, ticket) in tickets.enumerated() {
            totalTime += min(ticket, i <= k ? tickets[k] : tickets[k] - 1)
        }
        
        return totalTime
    }
}
